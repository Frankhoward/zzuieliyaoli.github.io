---
layout: post
title:  "ajax整理"
date:   2014-12-15 
categories: [javascript-learning]
---
http://blog.csdn.net/liubag/article/details/7608540

1.ajax 能够向服务器请求额外数据而无须卸载页面，与数据格式无关。
2.核心是 XMLHttpRequest 对象。虽然名字中包含XML。
3.创建XHR对象 
function createXHR(){
	if (typeof XMLHttpRequest != "undefined") {  //?
		return new XMLHttpRequest);
	}else if (typeof ActiveXObject != "undefined"){  // ?
		if (typeof arguments.callee.activeXString != "string" ) {
			var versions = arguments = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],
			    i, len;
			for (i=0,len=versions.length; i < len; i++){
				try{
					new ActiveXObject(versions[i]);
					arguments.callee.activeXString = versions[i];
					break;
				} catch (ex){
					//pass
				}
			}
		}
	}else {
		throw new Error ("No XHR object available");
	}
}

4.一个基本的AJAX实现
http://www.cnblogs.com/rubylouvre/archive/2013/01/08/2851051.html

// 跨平台取得XMLHttpRequest对象
var ajax = new(self.XMLHttpRequest||ActiveXObject)("Microsoft.XMLHTTP")
// 绑定事件回调
ajax.onreadystatechange = function(){
  //判断处理状态
  if (ajax.readyState==4 && ajax.status==200){
      alert(ajax.responseText)
  }
}
// 发出请求
ajax.open("POST", url, true);
// 设置首部
ajax.setRequestHeader();
// 在POST请求时，通过send方法发送请求
ajax.send("key=val&key1=val2");

5.XHR对象的方法。
5.1 open() 三个参数 1.请求的类型 post get 2. 基于当前页面的请求的URL（可以使用绝对路径） 3.布尔值 是否异步 
	注意：调用open()方法并不会真正发送请求，而只是启动一个请求以备发送；不能跨域，只能向同一个域中使用相同端口和协议的URL发送请求。
5.2 send()发送特殊请求，一个参数：作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null值
5.3 abort() 在收到响应之前，取消异步请求 调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。
5.4 setRequestHeader()方法设置自定义的请求头部信息。两个参数：头部字段的名称和头部字段的值；


同步 JavaScript代码会等到服务器响应之后再继续执行
6.1收到响应后，响应的数据会自动填充XHR对象的属性 responseText（作为响应主体被返回来的文本） responseXML（P573） status（状态码） statusText （HTTP状态的说明）
6.2响应后，first step是检查status属性，以确定相应已经成功返回。
6.3通过检测status来确定下一步的操作，不要依赖statusText，因为后者在跨浏览器使用时不太可靠。

异步
7.1加测XHR对象的readyState属性 表示请求/响应过程的当前活动阶段
7.2 0 1 2 3 4 
7.3 只要readyState属性的值由一个值编程另一个值，都会触发一次readyStatechange事件；必须在调用open()之前指定onreadyStatechange事件处理程序才能确保跨浏览器兼容性。

xhr.onreadystatechange = function(event){
            if (xhr.readyState == 4) {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                    alert(xhr.responseText);
                }else{
                    alert("Request was unsuccessful: " + xhr.status);
                }
            }
        };
7.4 onreadystatuschange 没有向时间处理程序中传入event对象，必须通过XHR对象本身来确定下一步该怎么做。
7.5 在事件处理程序中直接使用XHR对象，没有使用this对象，是由于onreadystatechange时间处理程序的作用域问题。
	如果使用，在某些浏览器中会导致函数执行失败

8.在终止请求之后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。

9.HTTP头部信息
9.1 每个HTTP请求和响应都会带有相应的头部信息。
9.2 setRequestHeader()方法设置自定义的请求头部信息。两个参数：头部字段的名称和头部字段的值；
    必须在open()之后 send()方法之前调用
9.3 getResponseHeader() 调用并传入头部字段名称，可以取得响应的响应头部信息
9.4 getAllResponseHeaders() 调用可以取得一个包含所有头部信息的长字符串

10.GET请求 最常见的请求类型，最常用于服务器查询某些信息
10.1查询字符串中的每个参数的名称和值都必须使用encodeURIComponent（）进行编码
P131 endcodeURIComponent

function addURLParam( url, name, value){
    url += (url.indexOf("?") == -1 ? "?" : "&");
    url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
    return url;
}

11 POST 用于向服务器发送应该被保存的数据 把数据当为请求的主体提交
11.1传入XML DOM文档，传入的文档经过序列化之后将作为请求组主体被提交到服务器；任何字符串
11.2服务器对POST请求和提交Web表单的请求并不会一视同仁，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分

12 XMLHttpRequest level 2
12.1 formData 序列化表单和创建与表单格式相同的数据（用于通过XHR传输数据）
12.2 append()
12.3用法 1.直接 先创建对象，再append添加 2.直接创建再添加
http://www.cnblogs.com/rubylouvre/archive/2011/04/26/2028827.html

13.超时设定 IE8+

14.overrideMimeType 强制修改

15.进度事件
15.1 load事件 
15.1.1 只要浏览器收到服务器的响应，不管状态如何，都会触发load事件
15.1.2 onload事件处理程序接受event对象，event.target指向XHR对象，因此可以访问XHR对象的所有方法和属性。

15.2 progress事件 在浏览器接收新数据期间周期性的触发
15.2.2 onprogress evnet对象 event.target指向XHR对象
15.2.3 额外的三个属性 
lengthComputable: 表示进度信息是否可用的布尔值
position： 表示已经接受的字节数
totalSize： 表示根据Content-Length响应头部确定的预期字节数

16.跨域资源共享 CORS
基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
注意：请求和响应都不包含cookie信息

17.其他跨域技术
17.1 图像ping
17.2 JSONP